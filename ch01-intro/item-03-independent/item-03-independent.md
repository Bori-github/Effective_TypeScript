# 코드 생성과 타입이 관계 없음을 이해하기 | Effective TypeScript
#### 타입스크립트 컴파일러의 두 가지 역할
1. 최신 타입스크립트/자바스크립트를 브라우저에서 동작할 수 있도록 구버전의 자바스크립트로 트랜스파일 합니다.
2. 코드의 타입 오류를 체크합니다.

위의 두 가지 역할은 서로 완벽히 독립적입니다.
따라서 타입스크립트가 자바스크립트로 변환될 때, 자바스크립트 실행 시점에 타입은 영향을 미치지 않습니다.

## 타입 오류가 있는 코드도 컴파일이 가능합니다.
- 컴파일은 타입 체크와 독립적으로 동작하므로, 타입 오류가 있는 코드도 컴파일이 가능합니다.
	- 타입스크립트 오류는 문제가 될 만한 부분을 알려주는 것입니다.
	- 따라서, 빌드를 멈추지는 않습니다.
- 반면, C나 자바 같은 언어는 타입 체크와 컴파일이 동시에 이루어집니다.
- 오류가 있을 때 컴파일하지 않으려면, tsconfig.json에 noEmitOnError 설정하거나 빌드 도구에 동일하게 적용하면 됩니다.

## 런타임에는 타입 체크가 불가능합니다.

![](https://i.imgur.com/1UJqcrE.png)

### 위 예시의 문제점
- `instanceof` 체크는 런타임에 일어나지만, `Rectangle`은 타입이기 때문에 런타임 시점에 아무런 역할을 할 수 없습니다.
- 타입스크립트의 타입은 제거 가능(erasable)하므로 실제 자바스크립트로 *컴파일되는 과정에서 모든 인터페이스, 타입, 타입 구문은 제거됩니다.

따라서, 런타임에 타입 정보를 유지하는 방법이 필요합니다.

##### *컴파일 : 컴파일이 아니라 '트랜스파일'이라고 하는 것이 더 정확하다고 생각합니다.

### 런타임에 타입 정보를 유지하는 방법
#### 1. `height` 속성의 존재 여부를 체크합니다.
- 속성 체크는 런타임에 접근 가능한 값입니다.
- 타입 체커도 shape의 타입을 Rectangle로 보정해 주기 때문에 오류가 사라집니다.

![](https://i.imgur.com/KrntDWY.png)

#### 2. 타입 정보를 명시적으로 저장하는 '태그' 기법을 사용합니다.
- `Shape` 타입은 '태그된 유니온(tagged union)'의 한 예입니다.

![](https://i.imgur.com/6MfuIOZ.png)

#### 3. 타입을 클래스로 만듭니다.
- 인터페이스를 타입으로만 사용 가능하지만, 클래스로 선언하면 타입과 값으로 모두 사용할 수 있습니다.

![](https://i.imgur.com/71sc6Pq.png)

## 타입 연산은 런타임에 영향을 주지 않습니다.
`string` 또는 `number` 타입인 값을 항상 `number`로 정제하는 예시입니다.

![](https://i.imgur.com/NvQ55Cp.png)

### 위 예시의 문제점
- 타입 체커는 통과하지만 자바스크립트로 변환된 코드를 보면 실제 이 함수는 아무런 정제 과정이 없습니다.
- `as number`는 타입 연산이므로 런타임 동작에 아무런 영향을 미치지 않습니다.

![](https://i.imgur.com/qqLm8jr.png)

### 문제 해결 방법
- 값을 정제하기 위해 런타임의 타입을 체크해야 하고 자바스크립트 연산을 통해 변환을 수행해야 합니다.

![](https://i.imgur.com/vVZZg72.png)

## 런타임 타입은 선언된 타입과 다를 수 있습니다.

다음 함수를 보고 마지막의 `console.log`까지 실행될 수 있을지 생각해봅시다.

![](https://i.imgur.com/QRGmmYj.png)

- 타입스크립트는 일반적으로 실행되지 못하는 죽은 코드를 찾아내지만, 여기서는 strict를 설정하더라도 찾아내지 못합니다.
- `: boolean`은 타입 선언문이므로 런타임에 제거됩니다.
- 자바스크립트였다면 실수로 `boolean` 값이 아닌 값으로 인해 마지막의 `console.log`가 실행될 수 있습니다.

**순수 타입스크립트에서도 마지막 코드를 실행하는 방법이 존재할까요?**

![](https://i.imgur.com/NMJJjyf.png)

- 네트워크 호출로부터 받아온 값으로 함수를 실행하는 경우가 있습니다.
- 요청의 결과로 `boolean` 값을 반환하라고 선언하더라도, 실제로 그렇게 되리라는 보장은 없습니다.
	- API를 잘못 파악하여 반환값이 문자열일 수 있습니다.
	- 배포된 후 API가 변경되어 반환값이 달라질 수 있습니다.

이처럼 타입스크립트에서는 런타임 타입과 선언된 타입이 맞지 않을 수 있다는 것을 명심해야 합니다.

## 타입스크립트 타입으로는 함수를 오버로드할 수 없습니다.
- 함수 오버로딩은 같은 이름의 함수에 매개변수를 다르게 사용하여 매개 변수에 따라 다른 함수가 실행되는 것을 의미합니다.
- 자바스크립트에는 함수 오버로딩 기능이 없습니다.
- 타입과 런타임의 동작이 무관하므로, 타입스크립트 또한 함수 오버로딩이 불가능합니다.

![](https://i.imgur.com/27Ck3ie.png)

하지만, **타입스크립트는 함수 오버로딩 기능을 지원합니다.**

- 타입스크립트의 함수 오버로딩에는 선언부(오버로드 시그니처)와 구현부(구현 시그니처)로 나뉩니다.
	- 선언부에서 매개변수의 타입을 지정하고, 함수의 구현은 구현부에서 이루어집니다.
- 하나의 함수에 대해 여러 개의 선언문을 작성할 수 있지만, 구현체(implementation)는 오직 하나입니다.

![](https://i.imgur.com/EFICt9D.png)

- 위의 예시에서 `add`에 대한 처음 두 개의 선언문은 타입 정보를 제공합니다.
- 이 두 선언문은 타입스크립트가 자바스크립트로 변환되면서 제거되고, 구현체만 남게됩니다.

## 타입스크립트 타입은 런타임 성능에 영향을 주지 않습니다.
- 타입과 타입 연산자는 자바스크립트 변환 시점에 제거되기 때문에, 런타임의 성능에 아무런 영향을 주지 않습니다.
-  타입스크립트 컴파일러는 런타임 오버헤드는 없으나 빌드타임 오버헤드가 있습니다.

## 요약
- 코드 생성은 타입 시스템과 무관합니다. 타입스크립트 타입은 런타임 동작이나 성능에 영향을 주지 않습니다.
- 타입 오류가 존재하더라도 코드 생성(컴파일)은 가능합니다.
- 타입스크립트 타입은 런타임에 사용할 수 없습니다. 런타임에 타입을 지정하려면, 타입 정보 유지를 위한 별도의 방법이 필요합니다. 일반적으로는 태그된 유니온과 속성 체크 방법을 사용합니다. 또는 클래스 같이 타입스크립트 타입과 런타임 값, 둘 다 제공하는 방법이 있습니다.

> 참고
> - [TypeScript: Documentation - More on Functions](https://www.typescriptlang.org/ko/docs/handbook/2/functions.html#%ED%95%A8%EC%88%98-%EC%98%A4%EB%B2%84%EB%A1%9C%EB%93%9C)
> - [[TypeScript] 함수와 함수 오버로딩](https://charles098.tistory.com/163)